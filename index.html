<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperliquid Funding Analyzer</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', 'sans-serif'],
                        'mono': ['Inter', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        'hl': {
                            'bg': '#0b0b0f',
                            'card': '#12121a',
                            'tertiary': '#1a1a24',
                            'border': '#1e1e2e',
                            'accent': '#50e3c2',
                            'accent2': '#7c3aed',
                            'positive': '#3fb68b',
                            'negative': '#ff5353',
                            'neutral': '#6b7280',
                            'text': '#e5e7eb',
                            'muted': '#9ca3af',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --bg-primary: #0b0b0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --border-color: #1e1e2e;
            --text-primary: #e5e7eb;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --accent: #50e3c2;
            --positive: #3fb68b;
            --negative: #ff5353;
            --neutral: #6b7280;
        }
        .light-mode {
            --bg-primary: #f5f7fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #eef1f5;
            --border-color: #d1d9e6;
            --text-primary: #1e2a3b;
            --text-secondary: #3d5066;
            --text-muted: #6b7c93;
            --accent: #0891b2;
            --positive: #059669;
            --negative: #dc2626;
        }
        .light-mode .card {
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.06);
        }
        .light-mode .hl-table th {
            background: #f8fafc;
            border-bottom: 2px solid var(--border-color);
        }
        .light-mode .hl-table tr:hover {
            background: #f1f5f9;
        }
        .light-mode .text-hl-positive {
            color: #047857 !important;
        }
        .light-mode .text-hl-negative {
            color: #b91c1c !important;
        }
        .light-mode .text-hl-accent {
            color: #0e7490 !important;
        }
        .light-mode .bg-hl-accent {
            background: #0891b2 !important;
        }
        .light-mode input {
            border-color: #cbd5e1 !important;
        }
        .light-mode input:focus {
            border-color: #0891b2 !important;
        }
        body {
            background: var(--bg-primary);
            font-family: 'Inter', system-ui, sans-serif;
            color: var(--text-primary);
        }
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        @keyframes pulse-glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .live-indicator {
            animation: pulse-glow 2s ease-in-out infinite;
        }
        /* Tabela compacta estilo Hyperliquid */
        .hl-table {
            font-variant-numeric: tabular-nums;
            width: auto;
        }
        .hl-table th {
            font-weight: 500;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: var(--text-muted);
            padding: 6px 6px;
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
        }
        .hl-table td {
            padding: 5px 6px;
            font-size: 12px;
            border-bottom: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            white-space: nowrap;
        }
        .hl-table td:last-child {
            border-right: none;
        }
        .hl-table tr:hover {
            background: var(--bg-tertiary);
        }
        .hl-table thead th {
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
        }
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #3e3e4e;
        }
        /* Sparkline */
        .sparkline {
            display: inline-block;
            vertical-align: middle;
        }
        /* Favorito */
        .favorite-star {
            cursor: pointer;
            transition: all 0.15s;
        }
        .favorite-star:hover {
            transform: scale(1.2);
        }
        .favorite-star.active {
            color: #fbbf24;
        }
    </style>
</head>
<body class="min-h-screen bg-hl-bg text-hl-text">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        // API Configuration - proxy via servidor local (sem CORS)
        const API_BASE = '/api/proxy';

        // ============================================
        // SQLite Backend via Server API
        // ============================================
        class FundingDB {
            static async getMeta(key) {
                const res = await fetch(`/api/meta/${encodeURIComponent(key)}`);
                const data = await res.json();
                return data.value;
            }

            static async setMeta(key, value) {
                await fetch('/api/meta', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key, value })
                });
            }

            static async getAllMarketData() {
                const res = await fetch('/api/market-data');
                return await res.json();
            }

            static async saveAllMarketData(markets) {
                await fetch('/api/market-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(markets)
                });
            }

            static async getFundingHistory(coin) {
                const res = await fetch(`/api/funding-history/${encodeURIComponent(coin)}`);
                return await res.json();
            }

            static async saveFundingHistory(coin, history) {
                await fetch(`/api/funding-history/${encodeURIComponent(coin)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ history })
                });
            }

            static async getAllFundingHistory() {
                const res = await fetch('/api/funding-history');
                return await res.json();
            }

            static async saveBulkFundingHistory(histories) {
                await fetch('/api/funding-history-bulk', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(histories)
                });
            }

            static async getHistoryTimestamps() {
                const res = await fetch('/api/funding-history-timestamps');
                return await res.json();
            }

            static async clearAll() {
                await fetch('/api/data', { method: 'DELETE' });
            }

            static async getStats() {
                const res = await fetch('/api/stats');
                return await res.json();
            }
        }

        // Cache duration (em ms)
        const CACHE_DURATION = {
            MARKET_DATA: 2 * 60 * 1000, // 2 minutos para dados de mercado
        };

        // Categorias de ativos do Hyperliquid
        // HIP-3 assets têm formato "dex:COIN" (ex: xyz:TSLA, trade:NVDA)
        const TRADFI_SYMBOLS = [
            'USA500', 'HOOD', 'INTC', 'NVDA', 'TSLA', 'AMZN', 'MSFT', 'META', 'GOOGL',
            'AAPL', 'COIN', 'MSTR', 'AMD', 'NFLX', 'SPY', 'QQQ', 'GLD', 'SLV', 'USO',
            'XLE', 'XLF', 'XLK', 'XLV', 'GME', 'AMC', 'PLTR', 'SNAP', 'UBER', 'ABNB',
            'XYZ100', 'US500', 'NDX', 'DJI', 'GOLD', 'SILVER', 'OIL', 'USTECH'
        ];

        // Função para categorizar um ativo
        const categorizeAsset = (coin) => {
            // HIP-3 são os que têm ":" no nome (dex:COIN format)
            if (coin.includes(':')) {
                // Extrai o símbolo após o ":"
                const symbol = coin.split(':')[1];
                // Verifica se é TradFi
                if (TRADFI_SYMBOLS.some(t => symbol.toUpperCase().includes(t.toUpperCase()))) {
                    return 'TradFi';
                }
                return 'HIP-3';
            }
            // Perps tradicionais (sem ":" no nome)
            return 'Perps';
        };

        // Utility Functions
        const formatPercent = (value, decimals = 4) => {
            if (value === null || value === undefined || isNaN(value)) return '—';
            const sign = value >= 0 ? '+' : '';
            return `${sign}${(value * 100).toFixed(decimals)}%`;
        };

        const formatAPR = (hourlyRate) => {
            if (hourlyRate === null || hourlyRate === undefined || isNaN(hourlyRate)) return '—';
            const apr = hourlyRate * 24 * 365 * 100;
            const sign = apr >= 0 ? '+' : '';
            return `${sign}${apr.toFixed(2)}%`;
        };

        const formatNumber = (num, decimals = 2) => {
            if (num === null || num === undefined || isNaN(num)) return '—';
            return num.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
        };

        const formatTimestamp = (ts) => {
            return new Date(ts).toLocaleString('pt-BR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
            });
        };

        const getColorClass = (value) => {
            if (value === null || value === undefined || isNaN(value)) return 'text-hl-muted';
            if (value > 0) return 'text-hl-positive';
            if (value < 0) return 'text-hl-negative';
            return 'text-hl-muted';
        };

        // Loading Spinner Component
        const Spinner = () => (
            <div className="flex items-center justify-center p-8">
                <div className="relative">
                    <div className="w-12 h-12 border-4 border-hl-border rounded-full"></div>
                    <div className="w-12 h-12 border-4 border-hl-accent border-t-transparent rounded-full absolute top-0 left-0 animate-spin"></div>
                </div>
            </div>
        );

        // Sparkline Component - Mini gráfico de tendência
        const Sparkline = ({ data, width = 60, height = 20, positive }) => {
            if (!data || data.length < 2) return <span className="text-hl-muted text-xs">—</span>;

            const values = data.slice(0, 24).map(d => parseFloat(d.fundingRate)).reverse();
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;

            const points = values.map((v, i) => {
                const x = (i / (values.length - 1)) * width;
                const y = height - ((v - min) / range) * height;
                return `${x},${y}`;
            }).join(' ');

            const avg = values.reduce((a, b) => a + b, 0) / values.length;
            const color = avg >= 0 ? '#3fb68b' : '#ff5353';

            return (
                <svg width={width} height={height} className="sparkline">
                    <polyline
                        fill="none"
                        stroke={color}
                        strokeWidth="1.5"
                        points={points}
                    />
                </svg>
            );
        };

        // Stats Card Component
        const StatsCard = ({ title, value, subValue, colorClass, icon }) => (
            <div className="card p-4">
                <div className="flex items-center gap-2 mb-2">
                    <span className="text-lg">{icon}</span>
                    <span className="text-hl-muted text-sm font-medium">{title}</span>
                </div>
                <div className={`text-2xl font-bold ${colorClass}`}>{value}</div>
                {subValue && <div className="text-hl-muted text-sm mt-1">{subValue}</div>}
            </div>
        );

        // Sort Icon Component
        const SortIcon = ({ direction }) => (
            <span className="ml-1 text-hl-accent">
                {direction === 'asc' ? '↑' : direction === 'desc' ? '↓' : ''}
            </span>
        );

        // Funding Chart Component - SVG Nativo
        const FundingChart = ({ history, formatPercent, getColorClass }) => {
            const [chartPeriod, setChartPeriod] = useState('7d');
            const [showMA7, setShowMA7] = useState(true);
            const [showMA30, setShowMA30] = useState(false);
            const [tooltip, setTooltip] = useState(null);
            const chartRef = React.useRef(null);

            // Dimensões do gráfico
            const width = 800;
            const height = 320;
            const padding = { top: 20, right: 20, bottom: 40, left: 70 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Filtra dados baseado no período selecionado
            const now = Date.now();
            const periodMs = {
                '24h': 24 * 60 * 60 * 1000,
                '7d': 7 * 24 * 60 * 60 * 1000,
                '30d': 30 * 24 * 60 * 60 * 1000,
                '365d': 365 * 24 * 60 * 60 * 1000,
                'all': Infinity
            };

            const filteredHistory = useMemo(() => {
                return (history || [])
                    .filter(h => chartPeriod === 'all' || (now - h.time) <= periodMs[chartPeriod])
                    .slice()
                    .reverse();
            }, [history, chartPeriod]);

            // Calcula médias móveis
            const { ma7Data, ma30Data } = useMemo(() => {
                const calculateMA = (data, periods) => {
                    return data.map((item, index) => {
                        if (index < periods - 1) return null;
                        const slice = data.slice(index - periods + 1, index + 1);
                        const avg = slice.reduce((sum, d) => sum + parseFloat(d.fundingRate), 0) / periods;
                        return avg;
                    });
                };
                return {
                    ma7Data: calculateMA(filteredHistory, 7 * 24),
                    ma30Data: calculateMA(filteredHistory, 30 * 24)
                };
            }, [filteredHistory]);

            // Prepara dados para o gráfico
            const chartData = useMemo(() => {
                return filteredHistory.map((entry, index) => ({
                    time: entry.time,
                    funding: parseFloat(entry.fundingRate) * 100,
                    ma7: ma7Data[index] ? ma7Data[index] * 100 : null,
                    ma30: ma30Data[index] ? ma30Data[index] * 100 : null,
                    apr: parseFloat(entry.fundingRate) * 24 * 365 * 100,
                }));
            }, [filteredHistory, ma7Data, ma30Data]);

            // Calcula min/max para escala Y
            const { yMin, yMax } = useMemo(() => {
                const allValues = chartData.flatMap(d => [
                    d.funding,
                    showMA7 && d.ma7,
                    showMA30 && d.ma30
                ].filter(v => v !== null && v !== false && !isNaN(v)));

                const minValue = allValues.length > 0 ? Math.min(...allValues) : -0.01;
                const maxValue = allValues.length > 0 ? Math.max(...allValues) : 0.01;
                const valueRange = maxValue - minValue || 0.02;
                return {
                    yMin: minValue - valueRange * 0.1,
                    yMax: maxValue + valueRange * 0.1
                };
            }, [chartData, showMA7, showMA30]);

            // Funções de escala
            const scaleX = useCallback((index) => padding.left + (index / (chartData.length - 1 || 1)) * chartWidth, [chartData.length, chartWidth]);
            const scaleY = useCallback((value) => padding.top + chartHeight - ((value - yMin) / (yMax - yMin)) * chartHeight, [yMin, yMax, chartHeight]);

            // Gera path SVG para uma série de dados
            const generatePath = useCallback((data, key) => {
                const points = data
                    .map((d, i) => ({ x: scaleX(i), y: d[key], index: i }))
                    .filter(p => p.y !== null && !isNaN(p.y));

                if (points.length === 0) return '';

                return points.map((p, i) =>
                    `${i === 0 ? 'M' : 'L'} ${p.x.toFixed(2)} ${scaleY(p.y).toFixed(2)}`
                ).join(' ');
            }, [scaleX, scaleY]);

            // Gera labels do eixo Y
            const yLabels = useMemo(() => {
                const yTicks = 5;
                return Array.from({ length: yTicks + 1 }, (_, i) => {
                    const value = yMin + (yMax - yMin) * (i / yTicks);
                    return { value, y: scaleY(value) };
                });
            }, [yMin, yMax, scaleY]);

            // Gera labels do eixo X
            const xLabels = useMemo(() => {
                const xLabelCount = Math.min(6, chartData.length);
                if (chartData.length === 0) return [];
                return Array.from({ length: xLabelCount }, (_, i) => {
                    const index = Math.floor(i * (chartData.length - 1) / (xLabelCount - 1 || 1));
                    const entry = chartData[index];
                    if (!entry) return null;
                    return {
                        x: scaleX(index),
                        label: new Date(entry.time).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' })
                    };
                }).filter(Boolean);
            }, [chartData, scaleX]);

            // Estatísticas do período
            const periodStats = useMemo(() => ({
                avg: filteredHistory.length > 0
                    ? filteredHistory.reduce((sum, h) => sum + parseFloat(h.fundingRate), 0) / filteredHistory.length
                    : 0,
                max: filteredHistory.length > 0
                    ? Math.max(...filteredHistory.map(h => parseFloat(h.fundingRate)))
                    : 0,
                min: filteredHistory.length > 0
                    ? Math.min(...filteredHistory.map(h => parseFloat(h.fundingRate)))
                    : 0,
                count: filteredHistory.length
            }), [filteredHistory]);

            // Handler de mouse para tooltip
            const handleMouseMove = useCallback((e) => {
                if (!chartRef.current || chartData.length === 0) return;
                const rect = chartRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const svgWidth = rect.width;
                const relX = (x / svgWidth) * width - padding.left;
                const index = Math.round((relX / chartWidth) * (chartData.length - 1));

                if (index >= 0 && index < chartData.length) {
                    const data = chartData[index];
                    setTooltip({
                        x: scaleX(index),
                        y: scaleY(data.funding),
                        data: data
                    });
                }
            }, [chartData, scaleX, scaleY, chartWidth]);

            const handleMouseLeave = useCallback(() => setTooltip(null), []);

            // Posição da linha zero
            const zeroY = scaleY(0);
            const showZeroLine = yMin < 0 && yMax > 0;

            return (
                <div className="mt-6">
                    <div className="flex items-center justify-between mb-4 flex-wrap gap-3">
                        <h3 className="text-lg font-semibold text-hl-text">Evolução do Funding</h3>
                        <div className="flex items-center gap-2 flex-wrap">
                            <div className="flex bg-hl-bg rounded-lg p-1">
                                {['24h', '7d', '30d', '365d', 'all'].map(period => (
                                    <button
                                        key={period}
                                        onClick={() => setChartPeriod(period)}
                                        className={`px-3 py-1 rounded text-sm font-medium transition-all ${
                                            chartPeriod === period
                                                ? 'bg-hl-accent text-hl-bg'
                                                : 'text-hl-muted hover:text-hl-text'
                                        }`}
                                    >
                                        {period === 'all' ? 'Tudo' : period === '365d' ? '1 ANO' : period.toUpperCase()}
                                    </button>
                                ))}
                            </div>
                            <div className="flex gap-2">
                                <button
                                    onClick={() => setShowMA7(!showMA7)}
                                    className={`px-2 py-1 rounded text-xs font-medium transition-all border ${
                                        showMA7
                                            ? 'bg-yellow-500/20 border-yellow-500 text-yellow-400'
                                            : 'border-hl-border text-hl-muted hover:border-yellow-500'
                                    }`}
                                >
                                    MA 7d
                                </button>
                                <button
                                    onClick={() => setShowMA30(!showMA30)}
                                    className={`px-2 py-1 rounded text-xs font-medium transition-all border ${
                                        showMA30
                                            ? 'bg-purple-500/20 border-purple-500 text-purple-400'
                                            : 'border-hl-border text-hl-muted hover:border-purple-500'
                                    }`}
                                >
                                    MA 30d
                                </button>
                            </div>
                        </div>
                    </div>

                    <div className="grid grid-cols-4 gap-2 mb-4">
                        <div className="bg-hl-bg rounded-lg p-2 text-center">
                            <div className="text-hl-muted text-xs">Média</div>
                            <div className={`font-mono font-bold ${getColorClass(periodStats.avg)}`}>
                                {formatPercent(periodStats.avg)}
                            </div>
                        </div>
                        <div className="bg-hl-bg rounded-lg p-2 text-center">
                            <div className="text-hl-muted text-xs">Máximo</div>
                            <div className="font-mono font-bold text-hl-positive">
                                {formatPercent(periodStats.max)}
                            </div>
                        </div>
                        <div className="bg-hl-bg rounded-lg p-2 text-center">
                            <div className="text-hl-muted text-xs">Mínimo</div>
                            <div className="font-mono font-bold text-hl-negative">
                                {formatPercent(periodStats.min)}
                            </div>
                        </div>
                        <div className="bg-hl-bg rounded-lg p-2 text-center">
                            <div className="text-hl-muted text-xs">Períodos</div>
                            <div className="font-mono font-bold text-hl-accent">
                                {periodStats.count.toLocaleString()}
                            </div>
                        </div>
                    </div>

                    {chartData.length > 0 ? (
                        <div className="relative w-full overflow-x-auto">
                            <svg
                                ref={chartRef}
                                viewBox={`0 0 ${width} ${height}`}
                                className="w-full h-80 min-w-[600px]"
                                onMouseMove={handleMouseMove}
                                onMouseLeave={handleMouseLeave}
                            >
                                {/* Grid lines */}
                                {yLabels.map((tick, i) => (
                                    <g key={i}>
                                        <line
                                            x1={padding.left}
                                            y1={tick.y}
                                            x2={width - padding.right}
                                            y2={tick.y}
                                            stroke="#1e1e2e"
                                            strokeDasharray="3 3"
                                        />
                                        <text
                                            x={padding.left - 10}
                                            y={tick.y}
                                            fill="#6b7280"
                                            fontSize="10"
                                            textAnchor="end"
                                            dominantBaseline="middle"
                                        >
                                            {tick.value.toFixed(4)}%
                                        </text>
                                    </g>
                                ))}

                                {/* X axis labels */}
                                {xLabels.map((tick, i) => (
                                    <text
                                        key={i}
                                        x={tick.x}
                                        y={height - padding.bottom + 20}
                                        fill="#6b7280"
                                        fontSize="10"
                                        textAnchor="middle"
                                    >
                                        {tick.label}
                                    </text>
                                ))}

                                {/* Zero line */}
                                {showZeroLine && (
                                    <line
                                        x1={padding.left}
                                        y1={zeroY}
                                        x2={width - padding.right}
                                        y2={zeroY}
                                        stroke="#6b7280"
                                        strokeDasharray="5 5"
                                        strokeWidth="1"
                                    />
                                )}

                                {/* MA 30d line */}
                                {showMA30 && (
                                    <path
                                        d={generatePath(chartData, 'ma30')}
                                        fill="none"
                                        stroke="#a855f7"
                                        strokeWidth="2"
                                        strokeDasharray="5 5"
                                    />
                                )}

                                {/* MA 7d line */}
                                {showMA7 && (
                                    <path
                                        d={generatePath(chartData, 'ma7')}
                                        fill="none"
                                        stroke="#eab308"
                                        strokeWidth="2"
                                        strokeDasharray="5 5"
                                    />
                                )}

                                {/* Main funding line */}
                                <path
                                    d={generatePath(chartData, 'funding')}
                                    fill="none"
                                    stroke="#00d4aa"
                                    strokeWidth="1.5"
                                />

                                {/* Tooltip crosshair and dot */}
                                {tooltip && (
                                    <>
                                        <line
                                            x1={tooltip.x}
                                            y1={padding.top}
                                            x2={tooltip.x}
                                            y2={height - padding.bottom}
                                            stroke="#6b7280"
                                            strokeDasharray="2 2"
                                            strokeWidth="1"
                                        />
                                        <circle
                                            cx={tooltip.x}
                                            cy={tooltip.y}
                                            r="5"
                                            fill="#00d4aa"
                                            stroke="#0a0a0f"
                                            strokeWidth="2"
                                        />
                                    </>
                                )}
                            </svg>

                            {/* Tooltip box */}
                            {tooltip && (
                                <div
                                    className="absolute bg-hl-card border border-hl-border rounded-lg p-3 shadow-lg pointer-events-none z-10"
                                    style={{
                                        left: `${Math.min((tooltip.x / width) * 100, 75)}%`,
                                        top: '20px'
                                    }}
                                >
                                    <p className="text-hl-muted text-xs mb-1">
                                        {new Date(tooltip.data.time).toLocaleString('pt-BR')}
                                    </p>
                                    <p className={`font-mono font-bold ${tooltip.data.funding >= 0 ? 'text-hl-positive' : 'text-hl-negative'}`}>
                                        Funding: {tooltip.data.funding >= 0 ? '+' : ''}{tooltip.data.funding.toFixed(4)}%
                                    </p>
                                    <p className={`font-mono text-sm ${tooltip.data.apr >= 0 ? 'text-hl-positive' : 'text-hl-negative'}`}>
                                        APR: {tooltip.data.apr >= 0 ? '+' : ''}{tooltip.data.apr.toFixed(2)}%
                                    </p>
                                    {tooltip.data.ma7 !== null && showMA7 && (
                                        <p className="font-mono text-sm text-yellow-400">
                                            MA7d: {tooltip.data.ma7.toFixed(4)}%
                                        </p>
                                    )}
                                    {tooltip.data.ma30 !== null && showMA30 && (
                                        <p className="font-mono text-sm text-purple-400">
                                            MA30d: {tooltip.data.ma30.toFixed(4)}%
                                        </p>
                                    )}
                                </div>
                            )}
                        </div>
                    ) : (
                        <div className="h-80 flex items-center justify-center text-hl-muted">
                            Sem dados de histórico para exibir
                        </div>
                    )}

                    <div className="flex items-center justify-center gap-4 mt-2 text-xs text-hl-muted">
                        <span className="flex items-center gap-1">
                            <span className="w-3 h-0.5 bg-hl-accent"></span> Funding Rate
                        </span>
                        {showMA7 && (
                            <span className="flex items-center gap-1">
                                <span className="w-3 h-0.5 bg-yellow-500" style={{borderTop: '2px dashed'}}></span> MA 7d
                            </span>
                        )}
                        {showMA30 && (
                            <span className="flex items-center gap-1">
                                <span className="w-3 h-0.5 bg-purple-500" style={{borderTop: '2px dashed'}}></span> MA 30d
                            </span>
                        )}
                    </div>
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [marketData, setMarketData] = useState([]);
            const [fundingHistory, setFundingHistory] = useState({});
            const [loading, setLoading] = useState(true);
            const [loadingHistory, setLoadingHistory] = useState(false);
            const [historyProgress, setHistoryProgress] = useState({ current: 0, total: 0 });
            const [error, setError] = useState(null);
            const [fetchErrors, setFetchErrors] = useState([]); // Log de erros de fetch
            const [lastUpdate, setLastUpdate] = useState(null);
            const [sortConfig, setSortConfig] = useState({ key: 'volume24h', direction: 'desc' });
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedCoin, setSelectedCoin] = useState(null);
            const [categoryFilter, setCategoryFilter] = useState('All'); // All, Perps, Spot, TradFi, HIP-3
            const [darkMode, setDarkMode] = useState(true);
            const [favorites, setFavorites] = useState([]);
            const [showOnlyFavorites, setShowOnlyFavorites] = useState(false);
            const [blacklistedCoins, setBlacklistedCoins] = useState([]);
            const [newTokens, setNewTokens] = useState([]); // Tokens sem histórico (novos)
            const [prefsLoaded, setPrefsLoaded] = useState(false);
            const [filters, setFilters] = useState({
                minAPY: '',
                maxAPY: '',
                minVolume: '',
                minOI: '',
                minDays: ''
            });

            // Toggle dark mode
            useEffect(() => {
                document.body.classList.toggle('light-mode', !darkMode);
            }, [darkMode]);

            // Load preferences from server (with localStorage migration)
            useEffect(() => {
                const loadPreferences = async () => {
                    try {
                        // Load favorites
                        const favRes = await fetch('/api/preferences/favorites');
                        let serverFavorites = await favRes.json();

                        // Migrate from localStorage if server is empty
                        const localFavorites = localStorage.getItem('hl-favorites');
                        if (serverFavorites.length === 0 && localFavorites) {
                            serverFavorites = JSON.parse(localFavorites);
                            await fetch('/api/preferences/favorites', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(serverFavorites)
                            });
                            localStorage.removeItem('hl-favorites');
                            console.log('Migrated favorites to server');
                        }
                        setFavorites(serverFavorites);

                        // Load blacklist
                        const blRes = await fetch('/api/preferences/blacklist');
                        let serverBlacklist = await blRes.json();

                        // Migrate from localStorage if server is empty
                        const localBlacklist = localStorage.getItem('hl-blacklisted');
                        if (serverBlacklist.length === 0 && localBlacklist) {
                            serverBlacklist = JSON.parse(localBlacklist);
                            await fetch('/api/preferences/blacklist', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(serverBlacklist)
                            });
                            localStorage.removeItem('hl-blacklisted');
                            console.log('Migrated blacklist to server');
                        }
                        // Lista de tokens protegidos - NÃO são removidos da blacklist ao carregar
                        // (tokens importantes que podem dar erro 502 temporário)
                        const PROTECTED_TOKENS = new Set([
                            'HYPE', 'SOL', 'ZRO', 'ETH', 'kPEPE', 'APT', 'WIF', 'AVAX', 'ADA', 'TON',
                            'PENDLE', 'OP', 'IP', 'kBONK', 'ETHFI', 'XLM', 'ARB', 'SPX', 'kSHIB',
                            'POL', 'INJ', 'POPCAT', 'ATOM', 'SEI', 'PENGU', 'FIL', 'MNT', 'ZK',
                            'BTC', 'XRP', 'DOGE', 'LINK', 'UNI', 'LTC', 'BCH', 'DOT', 'MATIC',
                            'NEAR', 'TRX', 'ICP', 'AAVE', 'ETC', 'STX', 'IMX',
                            'TAO', 'SUI', 'ONDO', 'JUP', 'PYTH', 'TIA', 'WLD', 'BLUR', 'MEME'
                        ]);

                        // Não filtra mais a blacklist - mantém todos os tokens
                        const filteredBlacklist = serverBlacklist;
                        if (filteredBlacklist.length !== serverBlacklist.length) {
                            console.log(`Cleaned blacklist: removed ${serverBlacklist.length - filteredBlacklist.length} protected tokens`);
                            // Salva a lista limpa
                            await fetch('/api/preferences/blacklist', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(filteredBlacklist)
                            });
                        }
                        setBlacklistedCoins(filteredBlacklist);

                        // Load new tokens list
                        const ntRes = await fetch('/api/preferences/newtokens');
                        const serverNewTokens = await ntRes.json();
                        setNewTokens(serverNewTokens);

                        setPrefsLoaded(true);
                    } catch (e) {
                        console.error('Error loading preferences:', e);
                        // Fallback to localStorage
                        const localFav = localStorage.getItem('hl-favorites');
                        const localBl = localStorage.getItem('hl-blacklisted');
                        if (localFav) setFavorites(JSON.parse(localFav));
                        if (localBl) setBlacklistedCoins(JSON.parse(localBl));
                        setPrefsLoaded(true);
                    }
                };
                loadPreferences();
            }, []);

            // Save favorites to server
            useEffect(() => {
                if (!prefsLoaded) return;
                fetch('/api/preferences/favorites', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(favorites)
                }).catch(e => console.error('Error saving favorites:', e));
            }, [favorites, prefsLoaded]);

            // Save blacklist to server
            useEffect(() => {
                if (!prefsLoaded) return;
                fetch('/api/preferences/blacklist', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(blacklistedCoins)
                }).catch(e => console.error('Error saving blacklist:', e));
            }, [blacklistedCoins, prefsLoaded]);

            // Save new tokens to server
            useEffect(() => {
                if (!prefsLoaded) return;
                fetch('/api/preferences/newtokens', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newTokens)
                }).catch(e => console.error('Error saving new tokens:', e));
            }, [newTokens, prefsLoaded]);

            const toggleFavorite = (coin) => {
                setFavorites(prev =>
                    prev.includes(coin)
                        ? prev.filter(c => c !== coin)
                        : [...prev, coin]
                );
            };

            // Fetch with timeout
            const fetchWithProxy = async (url, options, timeoutMs = 30000) => {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), timeoutMs);

                try {
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    clearTimeout(timeout);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return response;
                } catch (err) {
                    clearTimeout(timeout);
                    if (err.name === 'AbortError') {
                        throw new Error('Timeout');
                    }
                    throw err;
                }
            };

            // Fetch with retry logic
            const fetchWithRetry = async (url, options, retries = 3) => {
                let lastError;
                for (let i = 0; i < retries; i++) {
                    try {
                        return await fetchWithProxy(url, options);
                    } catch (err) {
                        lastError = err;
                        console.warn(`Fetch attempt ${i + 1}/${retries} failed:`, err.message);
                        if (i < retries - 1) {
                            const delay = 1000 * (i + 1); // 1s, 2s, 3s
                            await new Promise(r => setTimeout(r, delay));
                        }
                    }
                }
                throw lastError;
            };

            // Migrar dados antigos e filtrar duplicados HIP-3
            const migrateMarketData = (data) => {
                if (!data || !Array.isArray(data)) return data;

                // Primeiro, pega todos os símbolos do DEX principal (sem ":")
                const mainDexSymbols = new Set(
                    data
                        .filter(m => !m.coin.includes(':'))
                        .map(m => m.coin.toUpperCase())
                );

                // Filtra: mantém DEX principal + HIP-3 que NÃO são duplicados
                return data
                    .filter(market => {
                        // Se não tem ":", é do DEX principal - mantém
                        if (!market.coin.includes(':')) return true;

                        // Se tem ":", extrai o símbolo e verifica se é duplicado
                        const parts = market.coin.split(':');
                        const symbol = parts[parts.length - 1].toUpperCase();
                        return !mainDexSymbols.has(symbol);
                    })
                    .map(market => {
                        // Corrige nomes com prefixo duplicado (ex: "xyz:xyz:TSLA" -> "xyz:TSLA")
                        let coin = market.coin;
                        if (coin.includes(':')) {
                            const parts = coin.split(':');
                            // Se tem mais de 2 partes ou prefixo duplicado, corrige
                            if (parts.length > 2 || (parts.length === 2 && parts[0] === parts[1].split(':')[0])) {
                                // Pega só o primeiro prefixo e o último símbolo
                                const dexName = parts[0];
                                const symbol = parts[parts.length - 1];
                                coin = `${dexName}:${symbol}`;
                            }
                        }
                        return {
                            ...market,
                            coin: coin,
                            category: categorizeAsset(coin)
                        };
                    });
            };

            const fetchMarketData = useCallback(async (forceRefresh = false) => {
                // Verifica cache primeiro
                if (!forceRefresh) {
                    try {
                        const lastUpdateTime = await FundingDB.getMeta('marketDataLastUpdate');
                        if (lastUpdateTime && (Date.now() - lastUpdateTime) < CACHE_DURATION.MARKET_DATA) {
                            const cachedData = await FundingDB.getAllMarketData();
                            if (cachedData && cachedData.length > 0) {
                                // Verifica se tem dados HIP-3 corrompidos (ex: "xyz:xyz:TSLA" ou só "xyz")
                                const hasCorruptedHip3 = cachedData.some(m => {
                                    if (!m.coin.includes(':')) return false;
                                    const parts = m.coin.split(':');
                                    // Corrompido se: mais de 2 partes OU segunda parte não tem letras maiúsculas (é só o dex name)
                                    return parts.length > 2 || !/[A-Z]/.test(parts[1]);
                                });

                                if (hasCorruptedHip3) {
                                    console.log('Detected corrupted HIP-3 data, forcing refresh...');
                                    // Continua para buscar dados novos
                                } else {
                                    console.log('Loading market data from server');
                                    const migratedData = migrateMarketData(cachedData);
                                    setMarketData(migratedData);
                                    setLastUpdate(new Date(lastUpdateTime));
                                    setError(null);
                                    return;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Error loading from server:', e);
                    }
                }

                try {
                    const response = await fetchWithProxy(API_BASE, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type: 'metaAndAssetCtxs' })
                    });

                    if (!response.ok) throw new Error('Failed to fetch market data');
                    
                    const data = await response.json();
                    const [meta, assetCtxs] = data;

                    const markets = meta.universe.map((market, index) => {
                        const ctx = assetCtxs[index];
                        const coin = market.name;
                        return {
                            coin: coin,
                            category: categorizeAsset(coin),
                            szDecimals: market.szDecimals,
                            maxLeverage: market.maxLeverage,
                            funding: parseFloat(ctx?.funding || 0),
                            openInterest: parseFloat(ctx?.openInterest || 0),
                            volume24h: parseFloat(ctx?.dayNtlVlm || 0),
                            markPrice: parseFloat(ctx?.markPx || 0),
                            oraclePx: parseFloat(ctx?.oraclePx || 0),
                            premium: parseFloat(ctx?.premium || 0),
                        };
                    });

                    // Atualiza os mercados principais MAS mantém os HIP-3 existentes
                    setMarketData(prev => {
                        const existingHip3 = prev.filter(m => m.coin.includes(':'));
                        return [...markets, ...existingHip3];
                    });
                    setLastUpdate(new Date());
                    setError(null);

                    // Busca os HIP-3 perp dexs (vai atualizar com dados frescos)
                    fetchHIP3Markets(markets);
                } catch (err) {
                    console.error('Error fetching market data:', err);
                    
                    // Tenta carregar do servidor mesmo que expirado
                    try {
                        const cachedData = await FundingDB.getAllMarketData();
                        if (cachedData && cachedData.length > 0) {
                            console.log('Using cached data from server');
                            const migratedData = migrateMarketData(cachedData);
                            setMarketData(migratedData);
                            const lastUpdateTime = await FundingDB.getMeta('marketDataLastUpdate');
                            setLastUpdate(new Date(lastUpdateTime || Date.now()));
                            setError('Usando dados em cache (API indisponível)');
                        } else {
                            setError(err.message);
                        }
                    } catch (e) {
                        setError(err.message);
                    }
                }
            }, []);

            // Fetch HIP-3 perp dexs (TradFi, stocks, etc) - IGNORA duplicados do DEX principal
            const fetchHIP3Markets = useCallback(async (existingMarkets) => {
                try {
                    // Lista de símbolos que já existem no DEX principal (sem prefixo)
                    const existingSymbols = new Set(
                        existingMarkets
                            .filter(m => !m.coin.includes(':')) // Só do DEX principal
                            .map(m => m.coin.toUpperCase())
                    );
                    
                    console.log('Existing symbols in main DEX:', existingSymbols.size);
                    
                    // Busca lista de perp dexs
                    const response = await fetchWithProxy(API_BASE, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type: 'perpDexs' })
                    });

                    if (!response.ok) {
                        console.log('HIP-3 perpDexs endpoint not available');
                        return [];
                    }

                    const dexs = await response.json();
                    console.log('Found HIP-3 dexs:', dexs);

                    // Para cada dex, busca os assets
                    const hip3Markets = [];
                    
                    for (const dex of dexs) {
                        if (!dex || !dex.name) continue;
                        
                        try {
                            const metaResponse = await fetchWithProxy(API_BASE, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    type: 'metaAndAssetCtxs',
                                    dex: dex.name
                                })
                            });

                            if (!metaResponse.ok) continue;
                            
                            const [meta, assetCtxs] = await metaResponse.json();
                            
                            if (meta && meta.universe) {
                                meta.universe.forEach((market, index) => {
                                    // market.name já vem com prefixo da API (ex: "xyz:TSLA")
                                    const coin = market.name;
                                    const symbol = coin.includes(':') ? coin.split(':')[1].toUpperCase() : coin.toUpperCase();

                                    // IGNORA se já existe no DEX principal (BTC, ETH, SOL, etc)
                                    if (existingSymbols.has(symbol)) {
                                        return; // Skip silently
                                    }

                                    const ctx = assetCtxs?.[index];
                                    hip3Markets.push({
                                        coin: coin,
                                        category: categorizeAsset(coin),
                                        szDecimals: market.szDecimals,
                                        maxLeverage: market.maxLeverage,
                                        funding: parseFloat(ctx?.funding || 0),
                                        openInterest: parseFloat(ctx?.openInterest || 0),
                                        volume24h: parseFloat(ctx?.dayNtlVlm || 0),
                                        markPrice: parseFloat(ctx?.markPx || 0),
                                        oraclePx: parseFloat(ctx?.oraclePx || 0),
                                        premium: parseFloat(ctx?.premium || 0),
                                        perpDex: dex.name,
                                    });
                                });
                            }
                        } catch (e) {
                            console.warn(`Error fetching dex ${dex.name}:`, e);
                        }
                    }

                    if (hip3Markets.length > 0) {
                        // Remove duplicados HIP-3: agrupa por símbolo base e mantém o de maior OI
                        const hip3BySymbol = {};
                        hip3Markets.forEach(market => {
                            // Extrai símbolo base (ex: "hyna:ETH-USDE" -> "ETH", "xyz:TSLA" -> "TSLA")
                            let baseSymbol = market.coin.includes(':') ? market.coin.split(':')[1] : market.coin;
                            // Remove sufixos como -USDC, -USDE, -USD
                            baseSymbol = baseSymbol.replace(/-(USDC|USDE|USD|USDT)$/i, '').toUpperCase();

                            const oiValue = (market.openInterest || 0) * (market.markPrice || 0);

                            if (!hip3BySymbol[baseSymbol] || oiValue > hip3BySymbol[baseSymbol].oiValue) {
                                hip3BySymbol[baseSymbol] = { market, oiValue };
                            }
                        });

                        const uniqueHip3 = Object.values(hip3BySymbol).map(item => item.market);
                        console.log(`Found ${hip3Markets.length} HIP-3 markets, kept ${uniqueHip3.length} unique (by highest OI)`);

                        setMarketData(prev => {
                            const allMarkets = [...prev.filter(m => !m.coin.includes(':')), ...uniqueHip3];
                            FundingDB.saveAllMarketData(allMarkets);
                            return allMarkets;
                        });
                    }
                } catch (err) {
                    console.warn('Error fetching HIP-3 markets:', err);
                }
            }, []);

            // Fetch funding history for a specific coin - COM PAGINAÇÃO
            const fetchFundingHistory = useCallback(async (coin, startTime = 0, fetchAll = true) => {
                try {
                    let allResults = [];
                    let currentStartTime = startTime;
                    let hasMore = true;
                    const MAX_PAGES = 100; // Limite de segurança
                    let page = 0;

                    while (hasMore && page < MAX_PAGES) {
                        const response = await fetchWithRetry(API_BASE, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                type: 'fundingHistory',
                                coin: coin,
                                startTime: currentStartTime
                            })
                        });

                        if (!response.ok) throw new Error(`Failed to fetch funding history for ${coin}`);
                        const data = await response.json();
                        
                        if (data.length === 0) {
                            hasMore = false;
                        } else {
                            allResults = [...allResults, ...data];
                            
                            // Se retornou menos de 500, não há mais dados
                            if (data.length < 500 || !fetchAll) {
                                hasMore = false;
                            } else {
                                // Próxima página: usa o timestamp mais antigo + 1ms
                                const oldestEntry = data[data.length - 1];
                                currentStartTime = oldestEntry.time + 1;
                                page++;
                                
                                // Delay entre páginas para evitar rate limiting
                                await new Promise(resolve => setTimeout(resolve, 200));
                            }
                        }
                    }

                    // Remove duplicados e ordena (mais recente primeiro)
                    const uniqueResults = Array.from(
                        new Map(allResults.map(item => [item.time, item])).values()
                    ).sort((a, b) => b.time - a.time);

                    return uniqueResults;
                } catch (err) {
                    console.error(`Error fetching funding history for ${coin}:`, err);
                    throw err; // Propaga o erro para ser capturado no painel de erros
                }
            }, []);

            // Fetch all funding histories - INCREMENTAL (só busca novos dados)
            // onlyNew = true: só busca coins sem histórico
            // forceFullRefresh = true: busca todos, mesmo os que já têm
            const fetchAllFundingHistories = useCallback(async (forceFullRefresh = false, onlyNew = false) => {
                if (marketData.length === 0) return;

                // Carrega cache existente do servidor
                let cachedHistory = {};
                let cachedTimestamps = {};
                
                try {
                    cachedHistory = await FundingDB.getAllFundingHistory();
                    cachedTimestamps = await FundingDB.getHistoryTimestamps();
                } catch (e) {
                    console.warn('Error loading from server:', e);
                }

                // Se forçar refresh completo, limpa timestamps (mas mantém dados antigos como fallback)
                const timestamps = forceFullRefresh ? {} : cachedTimestamps;

                // Se já tem dados em cache e não é refresh forçado, usa como base
                if (!forceFullRefresh && Object.keys(cachedHistory).length > 0) {
                    setFundingHistory(cachedHistory);
                }

                setLoadingHistory(true);

                // Filtra coins que NÃO estão na blacklist nem são novos tokens
                const availableCoins = marketData.filter(m =>
                    !blacklistedCoins.includes(m.coin) && !newTokens.includes(m.coin)
                );

                // Filtra coins que precisam de atualização
                let coinsToUpdate;

                if (onlyNew === 'favorites') {
                    // Modo "Favoritos": só coins que estão nos favoritos
                    coinsToUpdate = availableCoins.filter(market => favorites.includes(market.coin));
                    console.log(`Mode: FAVORITES ONLY - ${coinsToUpdate.length} coins`);
                } else if (onlyNew) {
                    // Modo "Buscar Novos": só coins que NÃO têm histórico nenhum
                    // Ordena por Open Interest (menor primeiro)
                    coinsToUpdate = availableCoins
                        .filter(market => {
                            const history = cachedHistory[market.coin];
                            return !history || history.length === 0;
                        })
                        .sort((a, b) => {
                            const oiA = (a.openInterest || 0) * (a.markPrice || 0);
                            const oiB = (b.openInterest || 0) * (b.markPrice || 0);
                            return oiA - oiB; // Menor OI primeiro
                        });
                    console.log(`Mode: ONLY NEW - ${coinsToUpdate.length} coins without history (sorted by OI ascending)`);
                } else if (forceFullRefresh) {
                    // Modo "Atualizar Tudo": todos os coins (exceto blacklist)
                    coinsToUpdate = [...availableCoins];
                    console.log(`Mode: FULL REFRESH - ${coinsToUpdate.length} coins`);
                } else {
                    // Modo normal: coins sem histórico OU com histórico > 1h
                    const ONE_HOUR = 60 * 60 * 1000;
                    coinsToUpdate = availableCoins.filter(market => {
                        const lastFetch = timestamps[market.coin];
                        if (!lastFetch) return true;
                        return (Date.now() - lastFetch) > ONE_HOUR;
                    });
                    console.log(`Mode: INCREMENTAL - ${coinsToUpdate.length} coins to update`);
                }

                setHistoryProgress({ current: 0, total: coinsToUpdate.length, coin: '' });

                if (coinsToUpdate.length === 0) {
                    console.log('All funding histories are up to date');
                    setLoadingHistory(false);
                    return;
                }

                console.log(`Updating ${coinsToUpdate.length} coins (${marketData.length - coinsToUpdate.length} already cached)`);

                const updatedHistories = { ...cachedHistory };
                const BATCH_SIZE = 1; // Um por vez para debug
                
                // Processa em batches paralelos
                for (let i = 0; i < coinsToUpdate.length; i += BATCH_SIZE) {
                    const batch = coinsToUpdate.slice(i, i + BATCH_SIZE);
                    
                    setHistoryProgress({ 
                        current: i, 
                        total: coinsToUpdate.length, 
                        coin: batch.map(m => m.coin.includes(':') ? m.coin.split(':')[1] : m.coin).join(', '),
                        isNew: batch.some(m => !cachedHistory[m.coin])
                    });

                    // Processa batch em paralelo
                    const batchResults = await Promise.all(
                        batch.map(async (market) => {
                            const existingHistory = cachedHistory[market.coin] || [];
                            const isFirstFetch = existingHistory.length === 0;

                            try {
                                let newHistory;

                                if (isFirstFetch) {
                                    newHistory = await fetchFundingHistory(market.coin, 0, true);

                                    // Se primeira busca retornou vazio, adiciona à lista de novos tokens e mostra no painel de erros
                                    if (newHistory.length === 0) {
                                        setNewTokens(prev => [...new Set([...prev, market.coin])]);
                                        const warnInfo = {
                                            coin: market.coin,
                                            time: new Date().toLocaleTimeString(),
                                            error: 'Novo token (sem histórico)',
                                            hadHistory: false
                                        };
                                        setFetchErrors(prev => [warnInfo, ...prev].slice(0, 50));
                                        console.log(`Token ${market.coin} marcado como novo (sem histórico)`);
                                    }
                                } else {
                                    const lastKnownTime = existingHistory[0].time;
                                    const updates = await fetchFundingHistory(market.coin, lastKnownTime, false);

                                    if (updates.length > 0) {
                                        const existingTimes = new Set(existingHistory.map(e => e.time));
                                        const uniqueUpdates = updates.filter(e => !existingTimes.has(e.time));
                                        newHistory = [...uniqueUpdates, ...existingHistory].sort((a, b) => b.time - a.time);
                                    } else {
                                        newHistory = existingHistory;
                                    }
                                }

                                return { coin: market.coin, history: newHistory, success: true };
                            } catch (err) {
                                console.error(`Error fetching ${market.coin}:`, err);
                                const errorMsg = err.message || String(err);
                                const errorInfo = {
                                    coin: market.coin,
                                    time: new Date().toLocaleTimeString(),
                                    error: errorMsg,
                                    hadHistory: existingHistory.length > 0
                                };
                                setFetchErrors(prev => [errorInfo, ...prev].slice(0, 50));

                                // Lista de tokens protegidos - nunca vão para blacklist (erro 502 é temporário)
                                const PROTECTED_TOKENS = new Set([
                                    'HYPE', 'SOL', 'ZRO', 'ETH', 'kPEPE', 'APT', 'WIF', 'AVAX', 'ADA', 'TON',
                                    'PENDLE', 'OP', 'IP', 'kBONK', 'ETHFI', 'XLM', 'ARB', 'SPX', 'kSHIB',
                                    'POL', 'INJ', 'POPCAT', 'ATOM', 'SEI', 'PENGU', 'FIL', 'MNT', 'ZK',
                                    'BTC', 'XRP', 'DOGE', 'LINK', 'UNI', 'LTC', 'BCH', 'DOT', 'MATIC',
                                    'NEAR', 'TRX', 'ICP', 'AAVE', 'ETC', 'STX', 'IMX',
                                    'TAO', 'SUI', 'ONDO', 'JUP', 'PYTH', 'TIA', 'WLD', 'BLUR', 'MEME'
                                ]);

                                // Se erro 502 e token NÃO é protegido, adiciona à blacklist
                                if (errorMsg.includes('502') && !PROTECTED_TOKENS.has(market.coin)) {
                                    setBlacklistedCoins(prev => [...new Set([...prev, market.coin])]);
                                    setMarketData(prev => prev.filter(m => m.coin !== market.coin));
                                    console.log(`Token ${market.coin} adicionado à blacklist (502)`);
                                }

                                return { coin: market.coin, history: existingHistory, success: false, error: errorMsg };
                            }
                        })
                    );

                    // Atualiza resultados do batch
                    for (const result of batchResults) {
                        updatedHistories[result.coin] = result.history;
                    }

                    // Atualiza estado
                    setFundingHistory({ ...updatedHistories });
                    
                    // Salva batch no servidor
                    await Promise.all(
                        batchResults
                            .filter(r => r.success)
                            .map(r => FundingDB.saveFundingHistory(r.coin, r.history))
                    );

                    // Delay entre batches para evitar rate limiting
                    if (i + BATCH_SIZE < coinsToUpdate.length) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }

                setHistoryProgress({ current: coinsToUpdate.length, total: coinsToUpdate.length, coin: '' });
                setLoadingHistory(false);

                const totalRecords = Object.values(updatedHistories).reduce((sum, h) => sum + h.length, 0);
                console.log(`Database updated: ${Object.keys(updatedHistories).length} coins, ${totalRecords.toLocaleString()} total records`);
            }, [marketData, fetchFundingHistory]);

            // Calculate funding metrics from history
            const calculateMetrics = useCallback((history) => {
                if (!history || history.length === 0) {
                    return { avg24h: null, avg7d: null, avg30d: null, avgAllTime: null, periods: 0, firstFunding: null };
                }

                const now = Date.now();
                const h24 = now - 24 * 60 * 60 * 1000;
                const d7 = now - 7 * 24 * 60 * 60 * 1000;
                const d30 = now - 30 * 24 * 60 * 60 * 1000;

                const rates24h = [];
                const rates7d = [];
                const rates30d = [];
                const ratesAll = [];

                history.forEach(entry => {
                    const time = entry.time;
                    const rate = parseFloat(entry.fundingRate);
                    
                    ratesAll.push(rate);
                    if (time >= h24) rates24h.push(rate);
                    if (time >= d7) rates7d.push(rate);
                    if (time >= d30) rates30d.push(rate);
                });

                const avg = (arr) => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : null;

                const firstEntry = history[history.length - 1];
                const firstFunding = firstEntry ? new Date(firstEntry.time) : null;

                return {
                    avg24h: avg(rates24h),
                    avg7d: avg(rates7d),
                    avg30d: avg(rates30d),
                    avgAllTime: avg(ratesAll),
                    periods: history.length,
                    firstFunding
                };
            }, []);

            // Enhanced market data with metrics
            const enhancedMarketData = useMemo(() => {
                return marketData.map(market => {
                    const history = fundingHistory[market.coin] || [];
                    const metrics = calculateMetrics(history);
                    return { ...market, ...metrics };
                });
            }, [marketData, fundingHistory, calculateMetrics]);

            // Sorted and filtered data
            const sortedData = useMemo(() => {
                let filtered = enhancedMarketData.filter(m => {
                    // Filtro de blacklist e novos tokens
                    if (blacklistedCoins.includes(m.coin)) return false;
                    if (newTokens.includes(m.coin)) return false;

                    // Filtro de pesquisa
                    const matchesSearch = m.coin.toLowerCase().includes(searchTerm.toLowerCase());

                    // Filtro de categoria
                    const matchesCategory = categoryFilter === 'All' || m.category === categoryFilter;

                    // Filtro de favoritos
                    const matchesFavorites = !showOnlyFavorites || favorites.includes(m.coin);

                    // Filtros avançados
                    const apy30d = m.avg30d ? m.avg30d * 24 * 365 * 100 : 0;
                    const apyAllTime = m.avgAllTime ? m.avgAllTime * 24 * 365 * 100 : 0;
                    const matchesAPY30d = !filters.minAPY || apy30d >= parseFloat(filters.minAPY);
                    const matchesAPYAllTime = !filters.maxAPY || apyAllTime >= parseFloat(filters.maxAPY);
                    const volume = m.volume24h / 1e6;
                    const matchesMinVolume = !filters.minVolume || volume >= parseFloat(filters.minVolume);
                    const oi = (m.openInterest * m.markPrice) / 1e6;
                    const matchesMinOI = !filters.minOI || oi >= parseFloat(filters.minOI);
                    const days = Math.floor(m.periods / 24);
                    const matchesMinDays = !filters.minDays || days >= parseFloat(filters.minDays);

                    return matchesSearch && matchesCategory && matchesFavorites && matchesAPY30d && matchesAPYAllTime && matchesMinVolume && matchesMinOI && matchesMinDays;
                });

                return filtered.sort((a, b) => {
                    let aVal, bVal;

                    // Para Open Interest, ordena pelo valor em USD (OI * markPrice)
                    if (sortConfig.key === 'openInterest') {
                        aVal = (a.openInterest || 0) * (a.markPrice || 0);
                        bVal = (b.openInterest || 0) * (b.markPrice || 0);
                    } else {
                        aVal = a[sortConfig.key];
                        bVal = b[sortConfig.key];
                    }

                    // Handle null values
                    if (aVal === null || aVal === undefined) aVal = sortConfig.direction === 'desc' ? -Infinity : Infinity;
                    if (bVal === null || bVal === undefined) bVal = sortConfig.direction === 'desc' ? -Infinity : Infinity;

                    if (sortConfig.direction === 'asc') {
                        return aVal > bVal ? 1 : -1;
                    }
                    return aVal < bVal ? 1 : -1;
                });
            }, [enhancedMarketData, sortConfig, searchTerm, categoryFilter, filters, showOnlyFavorites, favorites]);

            // Category counts for tabs
            const categoryCounts = useMemo(() => {
                const counts = { All: 0, Perps: 0, TradFi: 0, 'HIP-3': 0 };
                enhancedMarketData.forEach(m => {
                    counts.All++;
                    if (counts[m.category] !== undefined) {
                        counts[m.category]++;
                    }
                });
                return counts;
            }, [enhancedMarketData]);

            // Global statistics (filtered by category)
            const globalStats = useMemo(() => {
                const dataToUse = categoryFilter === 'All' ? enhancedMarketData : enhancedMarketData.filter(m => m.category === categoryFilter);
                const withFunding = dataToUse.filter(m => m.funding !== null && !isNaN(m.funding));
                const avgFunding = withFunding.length > 0 
                    ? withFunding.reduce((sum, m) => sum + m.funding, 0) / withFunding.length 
                    : 0;
                const positive = withFunding.filter(m => m.funding > 0).length;
                const negative = withFunding.filter(m => m.funding < 0).length;
                const totalOI = dataToUse.reduce((sum, m) => sum + (m.openInterest * m.markPrice || 0), 0);
                const totalVolume = dataToUse.reduce((sum, m) => sum + (m.volume24h || 0), 0);

                return { avgFunding, positive, negative, totalOI, totalVolume, total: withFunding.length };
            }, [enhancedMarketData, categoryFilter]);

            // Handle sorting
            const handleSort = (key) => {
                setSortConfig(prev => ({
                    key,
                    direction: prev.key === key && prev.direction === 'desc' ? 'asc' : 'desc'
                }));
            };

            // Initial load - carrega do servidor primeiro
            useEffect(() => {
                const init = async () => {
                    setLoading(true);
                    
                    // Carrega histórico do servidor imediatamente
                    try {
                        const cachedHistory = await FundingDB.getAllFundingHistory();
                        if (cachedHistory && Object.keys(cachedHistory).length > 0) {
                            console.log('Loaded funding history from server');
                            setFundingHistory(cachedHistory);
                        }
                    } catch (e) {
                        console.warn('Error loading history from server:', e);
                    }
                    
                    await fetchMarketData();
                    setLoading(false);
                };
                init();
            }, [fetchMarketData]);

            // Auto-refresh every 60 seconds
            useEffect(() => {
                const interval = setInterval(() => fetchMarketData(true), 60000);
                return () => clearInterval(interval);
            }, [fetchMarketData]);

            // Fetch history after market data loads (se não tiver em cache)
            useEffect(() => {
                if (marketData.length > 0 && Object.keys(fundingHistory).length === 0) {
                    fetchAllFundingHistories();
                }
            }, [marketData, fundingHistory, fetchAllFundingHistories]);

            // Auto-refresh funding history every hour (incremental updates)
            useEffect(() => {
                if (marketData.length === 0) return;

                const AUTO_REFRESH_INTERVAL = 60 * 60 * 1000; // 1 hora

                const interval = setInterval(() => {
                    console.log('Auto-refresh: updating funding histories...');
                    fetchAllFundingHistories(false, false); // modo incremental
                }, AUTO_REFRESH_INTERVAL);

                return () => clearInterval(interval);
            }, [marketData, fetchAllFundingHistories]);

            // Table header component
            const TableHeader = ({ label, sortKey, className = '' }) => (
                <th 
                    className={`px-3 py-3 text-left text-xs font-semibold text-hl-muted uppercase tracking-wider cursor-pointer hover:text-hl-accent transition-colors ${className}`}
                    onClick={() => handleSort(sortKey)}
                >
                    <div className="flex items-center">
                        {label}
                        {sortConfig.key === sortKey && <SortIcon direction={sortConfig.direction} />}
                    </div>
                </th>
            );

            if (loading) {
                return (
                    <div className="min-h-screen flex items-center justify-center">
                        <div className="text-center">
                            <Spinner />
                            <p className="mt-4 text-hl-muted">Carregando dados do Hyperliquid...</p>
                        </div>
                    </div>
                );
            }

            if (error && marketData.length === 0) {
                return (
                    <div className="min-h-screen flex items-center justify-center">
                        <div className="text-center">
                            <div className="text-6xl mb-4">⚠️</div>
                            <p className="text-hl-negative text-xl">{error}</p>
                            <button 
                                onClick={() => window.location.reload()}
                                className="mt-4 px-6 py-2 bg-hl-accent text-hl-bg rounded-lg font-medium hover:bg-hl-accent/80 transition-colors"
                            >
                                Tentar novamente
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen p-4 md:p-6">
                    {/* Header */}
                    <div className="mb-6">
                        <div className="flex items-center justify-between flex-wrap gap-4">
                            <div>
                                <h1 className="text-2xl font-semibold" style={{color: 'var(--text-primary)'}}>
                                    Hyperliquid Funding
                                </h1>
                                <p className="text-sm" style={{color: 'var(--text-muted)'}}>
                                    Análise de funding rates • {marketData.length} pares
                                </p>
                            </div>
                            <div className="flex items-center gap-2 flex-wrap">
                                {lastUpdate && (
                                    <div className="flex items-center gap-2 text-xs" style={{color: 'var(--text-muted)'}}>
                                        <span className="w-1.5 h-1.5 bg-hl-positive rounded-full live-indicator"></span>
                                        <span>{formatTimestamp(lastUpdate)}</span>
                                    </div>
                                )}
                                <button
                                    onClick={() => fetchAllFundingHistories(true, 'favorites')}
                                    disabled={loadingHistory || favorites.length === 0}
                                    title="Atualiza histórico dos favoritos"
                                    className="px-2 py-1 bg-hl-card border border-hl-border rounded hover:border-yellow-500 hover:text-yellow-500 transition-colors disabled:opacity-50 text-xs"
                                >
                                    ⭐
                                </button>
                                <button
                                    onClick={() => fetchMarketData(true)}
                                    title="Atualiza funding atual, OI e volume"
                                    className="px-2 py-1 bg-hl-card border border-hl-border rounded hover:border-hl-accent transition-colors text-xs"
                                >
                                    Refresh
                                </button>
                                <button
                                    onClick={() => fetchAllFundingHistories(false, true)}
                                    disabled={loadingHistory}
                                    title="Busca histórico de coins sem dados"
                                    className="px-2 py-1 bg-hl-card border border-hl-border rounded hover:border-hl-positive hover:text-hl-positive transition-colors disabled:opacity-50 text-xs"
                                >
                                    + Novos
                                </button>
                                <button
                                    onClick={() => fetchAllFundingHistories(true, false)}
                                    disabled={loadingHistory}
                                    title="Atualiza todos os históricos"
                                    className="px-2 py-1 bg-hl-card border border-hl-border rounded hover:border-hl-accent2 hover:text-hl-accent2 transition-colors disabled:opacity-50 text-xs"
                                >
                                    Atualizar Tudo
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Cache Warning Banner */}
                    {error && marketData.length > 0 && (
                        <div className="mb-6 p-4 bg-yellow-900/20 border border-yellow-600/50 rounded-lg flex items-center gap-3">
                            <span className="text-yellow-500">⚠️</span>
                            <span className="text-yellow-200 text-sm">{error}</span>
                        </div>
                    )}

                    {/* Stats Overview - Compact */}
                    <div className="grid grid-cols-5 gap-2 mb-3">
                        <div className="card p-2.5">
                            <div className="text-[11px]" style={{color: 'var(--text-muted)'}}>Funding Médio</div>
                            <div className={`text-base font-semibold ${getColorClass(globalStats.avgFunding)}`}>{formatAPR(globalStats.avgFunding)}</div>
                        </div>
                        <div className="card p-2.5">
                            <div className="text-[11px]" style={{color: 'var(--text-muted)'}}>Positivo</div>
                            <div className="text-base font-semibold text-hl-positive">{globalStats.positive} <span className="text-[10px] font-normal" style={{color: 'var(--text-muted)'}}>({((globalStats.positive / globalStats.total) * 100).toFixed(0)}%)</span></div>
                        </div>
                        <div className="card p-2.5">
                            <div className="text-[11px]" style={{color: 'var(--text-muted)'}}>Negativo</div>
                            <div className="text-base font-semibold text-hl-negative">{globalStats.negative} <span className="text-[10px] font-normal" style={{color: 'var(--text-muted)'}}>({((globalStats.negative / globalStats.total) * 100).toFixed(0)}%)</span></div>
                        </div>
                        <div className="card p-2.5">
                            <div className="text-[11px]" style={{color: 'var(--text-muted)'}}>Open Interest</div>
                            <div className="text-base font-semibold text-hl-accent">${(globalStats.totalOI / 1e9).toFixed(2)}B</div>
                        </div>
                        <div className="card p-2.5">
                            <div className="text-[11px]" style={{color: 'var(--text-muted)'}}>Volume 24h</div>
                            <div className="text-base font-semibold text-hl-accent2">${(globalStats.totalVolume / 1e9).toFixed(2)}B</div>
                        </div>
                    </div>

                    {/* Loading History Progress */}
                    {loadingHistory && (
                        <div className="mb-3 p-2 card flex items-center gap-3 text-xs">
                            <div className="w-24 h-1 bg-hl-border rounded overflow-hidden">
                                <div
                                    className="h-full bg-hl-accent transition-all"
                                    style={{ width: `${(historyProgress.current / historyProgress.total) * 100}%` }}
                                />
                            </div>
                            <span style={{color: 'var(--text-muted)'}}>
                                Carregando {historyProgress.coin} ({historyProgress.current}/{historyProgress.total})
                            </span>
                        </div>
                    )}

                    {/* Filters Bar */}
                    <div className="mb-2 flex flex-wrap items-center gap-2">
                        {/* Category Tabs */}
                        <div className="flex items-center gap-1 p-1 bg-hl-card rounded-lg border border-hl-border">
                            {['All', 'Perps', 'TradFi', 'HIP-3'].map((category) => (
                                <button
                                    key={category}
                                    onClick={() => setCategoryFilter(category)}
                                    className={`px-3 py-1.5 rounded text-xs font-medium transition-all ${
                                        categoryFilter === category
                                            ? 'bg-hl-accent text-hl-bg'
                                            : 'text-hl-muted hover:text-hl-text'
                                    }`}
                                >
                                    {category}
                                    <span className={`ml-1 ${categoryFilter === category ? 'text-hl-bg/70' : 'text-hl-muted'}`}>
                                        {categoryCounts[category] || 0}
                                    </span>
                                </button>
                            ))}
                        </div>

                        {/* Favorites Toggle */}
                        <button
                            onClick={() => setShowOnlyFavorites(!showOnlyFavorites)}
                            className={`px-3 py-1.5 rounded text-xs font-medium border transition-all ${
                                showOnlyFavorites
                                    ? 'bg-yellow-500/20 border-yellow-500/50 text-yellow-400'
                                    : 'bg-hl-card border-hl-border text-hl-muted hover:text-hl-text'
                            }`}
                        >
                            ★ Favoritos {favorites.length > 0 && `(${favorites.length})`}
                        </button>

                        {/* Search */}
                        <input
                            type="text"
                            placeholder="Pesquisar..."
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            className="px-3 py-1.5 border border-hl-border rounded text-sm focus:outline-none focus:border-hl-accent transition-colors w-40"
                            style={{background: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                        />

                        {/* Theme Toggle */}
                        <button
                            onClick={() => setDarkMode(!darkMode)}
                            className="px-3 py-1.5 rounded text-xs font-medium bg-hl-card border border-hl-border text-hl-muted hover:text-hl-text transition-all ml-auto"
                        >
                            {darkMode ? '☀️ Light' : '🌙 Dark'}
                        </button>
                    </div>

                    {/* Advanced Filters */}
                    <div className="mb-2 flex flex-wrap items-center gap-2 text-xs">
                        <span style={{color: 'var(--text-muted)'}}>Filtros:</span>
                        <input
                            type="text"
                            inputMode="numeric"
                            placeholder="APY 30d %"
                            value={filters.minAPY}
                            onChange={(e) => setFilters({...filters, minAPY: e.target.value})}
                            className="px-2 py-1 border border-hl-border rounded w-24 focus:outline-none focus:border-hl-accent [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                            style={{background: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                        />
                        <input
                            type="text"
                            inputMode="numeric"
                            placeholder="APY All-Time %"
                            value={filters.maxAPY}
                            onChange={(e) => setFilters({...filters, maxAPY: e.target.value})}
                            className="px-2 py-1 border border-hl-border rounded w-28 focus:outline-none focus:border-hl-accent [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                            style={{background: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                        />
                        <input
                            type="text"
                            inputMode="numeric"
                            placeholder="Vol $M"
                            value={filters.minVolume}
                            onChange={(e) => setFilters({...filters, minVolume: e.target.value})}
                            className="px-2 py-1 border border-hl-border rounded w-20 focus:outline-none focus:border-hl-accent [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                            style={{background: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                        />
                        <input
                            type="text"
                            inputMode="numeric"
                            placeholder="OI $M"
                            value={filters.minOI}
                            onChange={(e) => setFilters({...filters, minOI: e.target.value})}
                            className="px-2 py-1 border border-hl-border rounded w-20 focus:outline-none focus:border-hl-accent [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                            style={{background: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                        />
                        <input
                            type="text"
                            inputMode="numeric"
                            placeholder="Dias"
                            value={filters.minDays}
                            onChange={(e) => setFilters({...filters, minDays: e.target.value})}
                            className="px-2 py-1 border border-hl-border rounded w-16 focus:outline-none focus:border-hl-accent [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                            style={{background: 'var(--bg-secondary)', color: 'var(--text-primary)'}}
                        />
                        {(filters.minAPY || filters.maxAPY || filters.minVolume || filters.minOI || filters.minDays) && (
                            <button
                                onClick={() => setFilters({ minAPY: '', maxAPY: '', minVolume: '', minOI: '', minDays: '' })}
                                className="px-2 py-1 text-hl-negative hover:bg-hl-negative/10 rounded"
                            >
                                Limpar
                            </button>
                        )}
                        <span style={{color: 'var(--text-muted)'}} className="ml-2">
                            {sortedData.length} resultados
                        </span>
                    </div>

                    {/* Main Table */}
                    <div className="card overflow-hidden">
                        <div className="overflow-x-auto max-h-[600px] overflow-y-auto">
                            <table className="hl-table">
                                <thead>
                                    <tr>
                                        <th className="sticky left-0 z-20" style={{background: 'var(--bg-secondary)'}}>
                                            <TableHeader label="Par" sortKey="coin" />
                                        </th>
                                        <th><TableHeader label="Funding" sortKey="funding" /></th>
                                        <th><TableHeader label="APY Atual" sortKey="funding" /></th>
                                        <th><TableHeader label="APY 24h" sortKey="avg24h" /></th>
                                        <th><TableHeader label="APY 7d" sortKey="avg7d" /></th>
                                        <th><TableHeader label="APY 30d" sortKey="avg30d" /></th>
                                        <th><TableHeader label="APY All-Time" sortKey="avgAllTime" /></th>
                                        <th><TableHeader label="OI" sortKey="openInterest" /></th>
                                        <th><TableHeader label="Vol 24h" sortKey="volume24h" /></th>
                                        <th><TableHeader label="Dias" sortKey="periods" /></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {sortedData.map((market) => {
                                        const handleRowClick = (e) => {
                                            if (e.target.closest('.favorite-star')) return;
                                            setSelectedCoin(selectedCoin === market.coin ? null : market.coin);
                                        };
                                        const isFavorite = favorites.includes(market.coin);
                                        return (
                                        <tr
                                            key={market.coin}
                                            className="cursor-pointer"
                                            onClick={handleRowClick}
                                        >
                                            <td className="sticky left-0 z-10" style={{background: 'var(--bg-secondary)'}}>
                                                <div className="flex items-center gap-2">
                                                    <span
                                                        className={`favorite-star ${isFavorite ? 'active' : 'text-hl-muted/30'}`}
                                                        onClick={(e) => { e.stopPropagation(); toggleFavorite(market.coin); }}
                                                    >
                                                        ★
                                                    </span>
                                                    <span className="font-medium" style={{color: 'var(--text-primary)'}}>
                                                        {market.coin.includes(':') ? market.coin.split(':')[1] : market.coin}
                                                    </span>
                                                    <span className={`text-[10px] px-1 py-0.5 rounded ${
                                                        market.category === 'HIP-3' ? 'bg-purple-500/20 text-purple-400' :
                                                        market.category === 'TradFi' ? 'bg-blue-500/20 text-blue-400' :
                                                        'bg-hl-border text-hl-muted'
                                                    }`}>
                                                        {market.category === 'Perps' ? 'PERP' : market.category}
                                                    </span>
                                                </div>
                                            </td>
                                            <td className={`font-medium ${getColorClass(market.funding)}`}>
                                                {formatPercent(market.funding)}
                                            </td>
                                            <td className={getColorClass(market.funding)}>
                                                {formatAPR(market.funding)}
                                            </td>
                                            <td className={getColorClass(market.avg24h)}>
                                                {formatAPR(market.avg24h)}
                                            </td>
                                            <td className={getColorClass(market.avg7d)}>
                                                {formatAPR(market.avg7d)}
                                            </td>
                                            <td className={getColorClass(market.avg30d)}>
                                                {formatAPR(market.avg30d)}
                                            </td>
                                            <td className={getColorClass(market.avgAllTime)}>
                                                {formatAPR(market.avgAllTime)}
                                            </td>
                                            <td style={{color: 'var(--text-secondary)'}}>
                                                ${formatNumber(market.openInterest * market.markPrice / 1e6)}M
                                            </td>
                                            <td style={{color: 'var(--text-secondary)'}}>
                                                ${formatNumber(market.volume24h / 1e6)}M
                                            </td>
                                            <td style={{color: 'var(--text-muted)'}}>
                                                {market.periods > 0 ? Math.floor(market.periods / 24).toLocaleString() : '—'}
                                            </td>
                                        </tr>
                                    );})}
                                </tbody>
                            </table>
                        </div>
                    </div>

                    {/* Selected Coin Detail - Modal Fixo */}
                    {selectedCoin && (
                        <div className="fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4" onClick={() => setSelectedCoin(null)}>
                            <div className="bg-hl-card border border-hl-border rounded-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                                <div className="p-6">
                                    <div className="flex items-center justify-between mb-4">
                                        <h2 className="text-xl font-bold text-hl-text">
                                            {selectedCoin.includes(':') ? selectedCoin.split(':')[1] : selectedCoin} - Detalhes do Funding
                                        </h2>
                                        <button
                                            onClick={() => setSelectedCoin(null)}
                                            className="text-hl-muted hover:text-hl-text transition-colors text-2xl"
                                        >
                                            ✕
                                        </button>
                                    </div>
                                
                                {(() => {
                                    const market = enhancedMarketData.find(m => m.coin === selectedCoin);
                                    const history = fundingHistory[selectedCoin];
                                    
                                    if (!market) return null;

                                    const days = Math.floor(market.periods / 24);
                                    return (
                                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                            <div className="p-4 bg-hl-bg rounded-lg">
                                                <div className="text-hl-muted text-sm mb-1">APY 24h</div>
                                                <div className={`text-2xl font-bold font-mono ${getColorClass(market.avg24h)}`}>
                                                    {formatAPR(market.avg24h)}
                                                </div>
                                            </div>
                                            <div className="p-4 bg-hl-bg rounded-lg">
                                                <div className="text-hl-muted text-sm mb-1">APY 7d</div>
                                                <div className={`text-2xl font-bold font-mono ${getColorClass(market.avg7d)}`}>
                                                    {formatAPR(market.avg7d)}
                                                </div>
                                            </div>
                                            <div className="p-4 bg-hl-bg rounded-lg">
                                                <div className="text-hl-muted text-sm mb-1">APY 30d</div>
                                                <div className={`text-2xl font-bold font-mono ${getColorClass(market.avg30d)}`}>
                                                    {formatAPR(market.avg30d)}
                                                </div>
                                            </div>
                                            <div className="p-4 bg-hl-bg rounded-lg">
                                                <div className="text-hl-muted text-sm mb-1">APY All-Time</div>
                                                <div className={`text-2xl font-bold font-mono ${getColorClass(market.avgAllTime)}`}>
                                                    {formatAPR(market.avgAllTime)}
                                                </div>
                                            </div>
                                            <div className="p-4 bg-hl-bg rounded-lg col-span-2">
                                                <div className="text-hl-muted text-sm mb-1">Open Interest</div>
                                                <div className="text-2xl font-bold font-mono text-hl-accent">
                                                    ${formatNumber(market.openInterest * market.markPrice / 1e6)}M
                                                </div>
                                                <div className="text-sm text-hl-muted">
                                                    {formatNumber(market.openInterest)} {selectedCoin}
                                                </div>
                                            </div>
                                            <div className="p-4 bg-hl-bg rounded-lg col-span-2">
                                                <div className="text-hl-muted text-sm mb-1">Histórico</div>
                                                <div className="text-2xl font-bold font-mono text-hl-accent2">
                                                    {days.toLocaleString()} dias
                                                </div>
                                                {market.firstFunding && (
                                                    <div className="text-sm text-hl-muted">
                                                        Desde: {formatTimestamp(market.firstFunding)}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })()}

                                {/* Funding Chart */}
                                <FundingChart
                                    history={fundingHistory[selectedCoin] || []}
                                    formatPercent={formatPercent}
                                    getColorClass={getColorClass}
                                />

                                {/* Monthly Averages Table */}
                                <div className="mt-6">
                                    <h3 className="text-lg font-semibold mb-3 text-hl-text">Últimos 24 Meses - Médias Mensais</h3>
                                    <div className="overflow-x-auto max-h-64 overflow-y-auto">
                                        <table className="w-full">
                                            <thead className="sticky top-0 bg-hl-card">
                                                <tr>
                                                    <th className="px-3 py-2 text-left text-xs font-semibold text-hl-muted">Mês/Ano</th>
                                                    <th className="px-3 py-2 text-left text-xs font-semibold text-hl-muted">Média Funding</th>
                                                    <th className="px-3 py-2 text-left text-xs font-semibold text-hl-muted">APR Médio</th>
                                                    <th className="px-3 py-2 text-left text-xs font-semibold text-hl-muted">Períodos</th>
                                                </tr>
                                            </thead>
                                            <tbody className="divide-y divide-hl-border">
                                                {(() => {
                                                    const history = fundingHistory[selectedCoin] || [];
                                                    if (history.length === 0) return <tr><td colSpan="4" className="px-3 py-4 text-center text-hl-muted">Sem dados de histórico</td></tr>;

                                                    // Agrupa por mês/ano
                                                    const monthlyData = {};
                                                    history.forEach(entry => {
                                                        const date = new Date(entry.time);
                                                        const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                                                        if (!monthlyData[key]) {
                                                            monthlyData[key] = { rates: [], year: date.getFullYear(), month: date.getMonth() };
                                                        }
                                                        monthlyData[key].rates.push(parseFloat(entry.fundingRate));
                                                    });

                                                    // Ordena por data (mais recente primeiro) e pega últimos 24 meses
                                                    const sortedMonths = Object.entries(monthlyData)
                                                        .sort((a, b) => b[0].localeCompare(a[0]))
                                                        .slice(0, 24);

                                                    const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];

                                                    return sortedMonths.map(([key, data]) => {
                                                        const avgRate = data.rates.reduce((a, b) => a + b, 0) / data.rates.length;
                                                        return (
                                                            <tr key={key} className="hover:bg-hl-bg/50">
                                                                <td className="px-3 py-2 text-sm text-hl-text font-mono font-medium">
                                                                    {monthNames[data.month]} {data.year}
                                                                </td>
                                                                <td className={`px-3 py-2 text-sm font-mono ${getColorClass(avgRate)}`}>
                                                                    {formatPercent(avgRate)}
                                                                </td>
                                                                <td className={`px-3 py-2 text-sm font-mono ${getColorClass(avgRate)}`}>
                                                                    {formatAPR(avgRate)}
                                                                </td>
                                                                <td className="px-3 py-2 text-sm font-mono text-hl-muted">
                                                                    {data.rates.length}
                                                                </td>
                                                            </tr>
                                                        );
                                                    });
                                                })()}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Error Log Panel */}
                    {fetchErrors.length > 0 && (
                        <div className="mt-4 p-3 rounded-lg border border-hl-negative/30 bg-hl-negative/5">
                            <div className="flex items-center justify-between mb-2">
                                <span className="text-sm font-medium text-hl-negative flex items-center gap-2">
                                    <span>⚠️</span> Erros de Fetch ({fetchErrors.length})
                                </span>
                                <button
                                    onClick={() => setFetchErrors([])}
                                    className="text-xs text-hl-muted hover:text-hl-negative transition-colors"
                                >
                                    Limpar
                                </button>
                            </div>
                            <div className="max-h-32 overflow-y-auto space-y-1 text-xs">
                                {fetchErrors.map((err, idx) => (
                                    <div key={idx} className="flex items-start gap-2 py-1 border-b border-hl-border/30 last:border-0">
                                        <span className="text-hl-muted whitespace-nowrap">{err.time}</span>
                                        <span className="font-medium text-hl-accent">{err.coin}</span>
                                        <span className="text-hl-negative flex-1">{err.error}</span>
                                        <span className={`text-xs ${err.hadHistory ? 'text-hl-positive' : 'text-hl-muted'}`}>
                                            {err.hadHistory ? '(tinha cache)' : '(sem cache)'}
                                        </span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Footer */}
                    <div className="mt-6 pt-4 border-t border-hl-border flex items-center justify-between text-xs" style={{color: 'var(--text-muted)'}}>
                        <div className="flex items-center gap-4 flex-wrap">
                            {Object.keys(fundingHistory).length > 0 && (
                                <span>{Object.values(fundingHistory).reduce((sum, h) => sum + h.length, 0).toLocaleString()} registros em cache</span>
                            )}
                            {blacklistedCoins.length > 0 && (
                                <span className="flex items-center gap-2">
                                    <span className="text-hl-negative">{blacklistedCoins.length} tokens com erro</span>
                                    <button
                                        onClick={() => {
                                            if (confirm(`Restaurar ${blacklistedCoins.length} tokens com erro (502)?`)) {
                                                setBlacklistedCoins([]);
                                            }
                                        }}
                                        className="text-hl-accent hover:underline"
                                    >
                                        (restaurar)
                                    </button>
                                </span>
                            )}
                            {newTokens.length > 0 && (
                                <span className="flex items-center gap-2">
                                    <span className="text-yellow-500">{newTokens.length} novos tokens</span>
                                    <button
                                        onClick={() => {
                                            if (confirm(`Restaurar ${newTokens.length} novos tokens (sem histórico)?`)) {
                                                setNewTokens([]);
                                            }
                                        }}
                                        className="text-hl-accent hover:underline"
                                    >
                                        (restaurar)
                                    </button>
                                </span>
                            )}
                        </div>
                        <button
                            onClick={async () => {
                                if (confirm('Limpar todo o histórico?')) {
                                    await FundingDB.clearAll();
                                    window.location.reload();
                                }
                            }}
                            className="hover:text-hl-negative transition-colors"
                        >
                            Limpar Cache
                        </button>
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
